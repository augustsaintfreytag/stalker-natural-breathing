-- References

local is_respi_on = actor_effects.is_respi_on
local is_mask_on = actor_effects.is_mask_on

-- Types

local SND_KIND = {
	DEFAULT = "breath",
	GAS_MASK = "gas_breath",
	HEALTH_RELATED = "health",
	STAMINA_RELATED = "run",
	STAMINA_RELATED_SWEETENER = "exhausted"
}

local SND_DEFAULT_BREATH_MODE = {
	DEFAULT = "1",
	DISTRESS = "2",
	FEAR = "3"
}

local SND_HEALTH_BREATH_MODE = {
	LIGHTLY_WOUNDED = "1",
	SEVERELY_WOUNDED = "2"
}

local SND_RUN_BREATH_MODE = {
	LIGHTLY_EXHAUSTED = "1",
	MODERATELY_EXHAUSTED = "2",
	SEVERELY_EXHAUSTED = "3"
}

-- State

local opt = {}
local snd_cooldown_time = 0

local last_actor_speed = 0
local last_actor_position = { x = 0, y = 0, z = 0 }
local last_actor_speed_time = 0
local last_cam_dist = 0

local actor_speaking_cooldown_time = 0

local breath_snd = nil

local snd_index_by_kind = {
	[SND_KIND.DEFAULT] = 0,
	[SND_KIND.GAS_MASK] = 0,
	[SND_KIND.HEALTH_RELATED] = 0,
	[SND_KIND.STAMINA_RELATED] = 0,
	[SND_KIND.STAMINA_RELATED_SWEETENER] = 0
}

local num_snds_by_kind = {
	[SND_KIND.DEFAULT] = 8,
	[SND_KIND.GAS_MASK] = 8,
	[SND_KIND.HEALTH_RELATED] = 8,
	[SND_KIND.STAMINA_RELATED] = 6,
	[SND_KIND.STAMINA_RELATED_SWEETENER] = 7
}

-- Residuality means a mode is retained for some time after the condition is no longer met.
-- A given kind and mode are kept until the associated cooldown is hit.
-- Can add forced state transitions where a mode always has to be cycled back up.

-- Format for values: `{ mode = nil, pause_factor = 0, time = 0 }`
local snd_residual_cooldown_by_kind = {}

-- Configuration

local residual_snd_kinds = { SND_KIND.HEALTH_RELATED, SND_KIND.STAMINA_RELATED }
local voiced_actor_blacklist = { "fear", "exhausted" }

-- Ticking

function tick_breath_snd_index(kind)
	local num_snds = num_snds_by_kind[kind]
	snd_index_by_kind[kind] = snd_index_by_kind[kind] % num_snds + 1

	return snd_index_by_kind[kind]
end

function reset_breath_snd_index(kind)
	snd_index_by_kind[kind] = 0
end

-- Init

function init_options()
	opt.speed = {}

	local ini_eff = ini_file("plugins\\actor_effects.ltx")
	local settings_speed = ini_eff:line_count("settings_speed")

	for i = 0, settings_speed - 1 do
		local _, id, value = ini_eff:r_line_ex("settings_speed", i, "", "")

		if id and value then
			opt.speed[id] = tonumber(value)
		end
	end

	opt.health = {
		injury_snd = nil,
		level1 = ini_eff:r_float_ex("settings_health", "level1"),
		level2 = ini_eff:r_float_ex("settings_health", "level2")
	}

	opt.cam_dist = ini_eff:r_float_ex("settings", "cam_dist") or 4

	opt.speaking_cooldown = 1000
	opt.residuality_time = 5000
	opt.fear_factor_npc_detection_radius = 60

	opt.breathing_sound_volume = 0.7
	opt.breathing_sound_volume_jitter = 0.1

	opt.enable_breathing_sound = ui_options.get("sound/environment/breathing_sound")
end

-- Actor Value Updates

function update_actor_cam_distance(actor)
	last_cam_dist = actor:bone_position("bip01_head"):distance_to_sqr(device().cam_pos)
end

function update_actor_speed(actor)
	local current_position = actor:position()
	local current_speed = (current_position.x - last_actor_position.x) ^ 2 +
		(current_position.y - last_actor_position.y) ^ 2 + (current_position.z - last_actor_position.z) ^ 2

	last_actor_position.x = current_position.x
	last_actor_position.y = current_position.y
	last_actor_position.z = current_position.z

	last_actor_speed = current_speed
end

function update_actor_speed_time()
	if (last_actor_speed > opt.speed.mini) then
		last_actor_speed_time = last_actor_speed_time + opt.speed.inc
	elseif last_actor_speed_time > opt.speed.dec then
		last_actor_speed_time = last_actor_speed_time - opt.speed.dec
	end

	last_actor_speed_time = math.min(32, last_actor_speed_time)
end

-- Actor Breathing Tick

function update_breathing(actor)
	if (not opt.enable_breathing_sound) then
		return
	end

	update_actor_cam_distance(actor)
	update_actor_speed(actor)
	update_actor_speed_time()

	if is_respi_on() then
		play_sound_breath_mask(actor)
	else
		play_sound_breath(actor)
	end
end

-- Actor Breathing (Masked)

function play_sound_breath_mask(actor)
	local current_time = time_global()

	if (current_time <= snd_cooldown_time) or (current_time < actor_speaking_cooldown_time) then
		return
	end

	local snd_index = tick_breath_snd_index(SND_KIND.GAS_MASK)
	local snd_mode = tostring((actor.health > 0.2) and math.ceil((1.01 - actor.power) * 3 + last_actor_speed_time / 8) or
		8)

	play_sound_with_parameters(actor, SND_KIND.GAS_MASK, snd_mode, snd_index, 1.25)
end

-- Actor Breathing (Unmasked)

function play_sound_breath(actor)
	local current_time = time_global()
	local actor_health = actor.health

	if (current_time < snd_cooldown_time) or (current_time < actor_speaking_cooldown_time) or (actor_health < 0) then
		return
	end

	-- Check residual sounds and play if found.
	for snd_kind, snd_record in pairs(snd_residual_cooldown_by_kind) do
		do
			if not snd_record or not snd_record.mode then
				goto continue
			end

			if current_time < snd_record.time then
				local snd_index = tick_breath_snd_index(snd_kind)
				play_sound_with_parameters(actor, snd_kind, snd_record.mode, snd_index, snd_record.pause_factor, true)

				printf("Playing residual sound of kind '" ..
					snd_kind .. "' with mode " .. snd_record.mode .. " and index " ..
					snd_index .. " (expiration in " .. snd_record.time - current_time .. "ms).")
			else
				printf("Clearing residual sound of kind '" ..
					snd_kind ..
					"' with mode " ..
					snd_record.mode .. " (expired since " .. current_time - snd_record.time .. "ms).")

				-- Residual time window exceeded, clear record.
				snd_residual_cooldown_by_kind[snd_kind] = nil
			end

			return
		end

		::continue::
	end
	if (actor_health <= opt.health.level1) then
		-- Player is badly wounded, play sounds for injury.
		local snd_index = tick_breath_snd_index(SND_KIND.HEALTH_RELATED)
		play_sound_with_parameters(actor, SND_KIND.HEALTH_RELATED, SND_HEALTH_BREATH_MODE.SEVERELY_WOUNDED,
			snd_index, 1.25)

		return
	end

	if (actor_health <= opt.health.level2 and actor_health > opt.health.level1) then
		local snd_index = tick_breath_snd_index(SND_KIND.HEALTH_RELATED)
		play_sound_with_parameters(actor, SND_KIND.HEALTH_RELATED, SND_HEALTH_BREATH_MODE.LIGHTLY_WOUNDED,
			snd_index, 1.25)

		return
	end

	if (actor.power < 0.05 and math.random() < 0.5) then
		local snd_index = tick_breath_snd_index(SND_KIND.STAMINA_RELATED_SWEETENER)
		play_sound_sweetener_with_parameters(actor, SND_KIND.STAMINA_RELATED_SWEETENER, snd_index, 1.25)

		return
	end

	-- Player is healthy, only play sounds for stamina or running.
	if actor.power < 0.85 then
		-- Player is running or low on stamina
		-- local snd_mode = clamp(math.ceil(3 / (3 * actor.power)), 1, 3)
		local snd_mode = math.ceil(3 * last_actor_speed_time / 44)
		local snd_index = tick_breath_snd_index(SND_KIND.STAMINA_RELATED) -- SND_RUN_BREATH_MODE (1â€“3)

		printf("Playing stamina-related breathing sound with mode " ..
			tostring(snd_mode) ..
			" and index " ..
			tostring(snd_index) ..
			" (stamina " .. tostring(actor.power) .. ", last speed time " .. tostring(last_actor_speed_time) .. ").")
		play_sound_with_parameters(actor, SND_KIND.STAMINA_RELATED, snd_mode, snd_index, 1.5)
		return
	end

	reset_breath_snd_index(SND_KIND.STAMINA_RELATED)

	-- Regular Breathing
	local snd_index = tick_breath_snd_index(SND_KIND.DEFAULT)
	local snd_mode = SND_DEFAULT_BREATH_MODE.DEFAULT
	local snd_pause_factor = 1.6

	-- Fear Factor
	local fear_factor = calculate_fear_factor()

	if fear_factor > 0.7 then
		snd_mode = SND_DEFAULT_BREATH_MODE.FEAR
		snd_pause_factor = 1.4
	elseif fear_factor > 0.3 then
		snd_mode = SND_DEFAULT_BREATH_MODE.DISTRESS
		snd_pause_factor = 1.5
	end

	printf("Playing default breathing sound with mode " ..
		tostring(snd_mode) .. " and index " .. tostring(snd_index) .. ".")

	play_sound_with_parameters(actor, SND_KIND.DEFAULT, snd_mode, snd_index, snd_pause_factor)
end

-- Sound Playback

function play_sound_with_parameters(actor, kind, mode, index, pause_factor, is_residual)
	breath_snd = sound_object("actor\\" .. kind .. "_" .. mode .. "_" .. index)
	breath_snd:play(actor, 0, sound_object.s2d)
	breath_snd.volume = actor_sound_volume()

	local current_time = time_global()
	local snd_duration = breath_snd:length() or 800

	snd_cooldown_time = current_time + snd_duration * pause_factor

	if not is_residual and table.has_value(residual_snd_kinds, kind) then
		printf("Adding residual sound record for kind '" .. kind .. "' with mode " .. mode .. ".")
		snd_residual_cooldown_by_kind[kind] = {
			mode = mode,
			pause_factor = pause_factor,
			time = current_time + opt.residuality_time
		}
	end
end

function play_sound_sweetener_with_parameters(actor, kind, index, pause_factor)
	breath_snd = sound_object("actor\\" .. kind .. "_" .. index)
	breath_snd:play(actor, 0, sound_object.s2d)
	breath_snd.volume = actor_sound_volume()

	local current_time = time_global()
	snd_cooldown_time = current_time + breath_snd:length() or 1000 * pause_factor
end

-- Sound Metadata

function actor_sound_volume(is_masked)
	if last_cam_dist > opt.cam_dist then
		return 0
	end

	local amplifier = (is_masked or false) and 0.5 or 1
	local jitter = opt.breathing_sound_volume_jitter * math.random(-50, 50) / 100

	return (1 - last_cam_dist / opt.cam_dist) * amplifier * opt.breathing_sound_volume + jitter
end

-- Fear Factor

function calculate_fear_factor()
	local is_night = get_is_night()
	local is_underground = get_is_underground()
	local is_in_combat = get_is_in_combat()
	local is_surge = get_is_surge()
	local is_in_safe_space = get_is_in_safe_space()
	local number_of_nearby_threats = get_number_of_nearby_threats()

	local fear_value = 0

	fear_value = fear_value + clamp(number_of_nearby_threats, 0, 4)
	fear_value = fear_value + clamp((1 / get_psy_health() - 1), 0, 5)

	if is_in_combat then
		fear_value = fear_value + 2
	end

	if is_night then
		fear_value = fear_value + 1
	end

	if is_underground then
		fear_value = fear_value + 2
	end

	if is_surge and not is_underground then
		fear_value = fear_value + 2
	end

	if is_in_safe_space and not is_underground then
		fear_value = fear_value / 2
	end

	local fear_factor = clamp(fear_value / 10, 0, 1)

	printf("Calculated aggregate player fear factor: " ..
		tostring(fear_factor) ..
		" (from value " ..
		fear_value ..
		") with factors (in combat: " ..
		tostring(is_in_combat) .. ", night: " .. tostring(is_night) .. ", underground: " ..
		tostring(is_underground) ..
		", surge: " .. tostring(is_surge) .. ", safe space: " .. tostring(is_in_safe_space) ..
		", nearby threats: " .. tostring(number_of_nearby_threats) .. ").")

	return fear_factor
end

-- Conditions

function get_is_surge()
	return xr_conditions.surge_started()
end

function get_is_night()
	return level.get_time_hours() < 3 or level.get_time_hours() > 22
end

function get_is_underground()
	return GetEvent("underground")
end

function get_is_in_safe_space()
	return GetEvent("current_safe_cover")
end

function get_is_in_combat()
	if not AGDD_voiced_actor then
		return false
	end

	return AGDD_voiced_actor.is_actor_in_combat() or false
end

function get_psy_health()
	if arszi_psy then
		return arszi_psy.get_psy_health()
	end

	return db.actor:psy_health()
end

function get_number_of_nearby_threats()
	local max_radius = opt.fear_factor_npc_detection_radius
	local npc_list = {} -- Records of { id, name, distance (unknown) }

	level.iterate_nearest(db.actor:position(), max_radius, function(obj)
		if (IsStalker(obj) or IsMonster(obj)) and obj:alive() and obj:relation(db.actor) == game_object.enemy then
			table.insert(npc_list, {
				id = obj:id()
			})
		end
	end)

	return #npc_list
end

-- Utility

function table.has_value(tab, val)
	for _, value in ipairs(tab) do
		if value == val then
			return true
		end
	end

	return false
end

-- Hook

function hook_functions()
	actor_effects.Update_Breathing = update_breathing
	actor_effects.play_sound_breath_mask = play_sound_breath_mask
	actor_effects.play_sound_breath = play_sound_breath

	if AGDD_voiced_actor then
		local original_actor_speak = AGDD_voiced_actor.actor_speak

		AGDD_voiced_actor.actor_speak = function(file, sound_volume, cooldown, chance, requires_squad, has_priority,
												 ignore_conditionals, is_state)
			-- Check blacklist, skip playback for sounds already handled in breathing script.
			for _, blacklisted_word in ipairs(voiced_actor_blacklist) do
				if string.find(file, blacklisted_word) then
					return
				end
			end

			-- Alter regular hurt sounds, block above higher health threshold.
			if string.find(file, "hurt_bad") then
				chance = chance / 4
			elseif string.find(file, "hurt") then
				if db.actor:health() > 0.5 then
					return
				end

				chance = chance / 4
			end

			-- Augment random chance for playback, replace voiced actor script logic.
			local rolled_chance = math.random(1, 100)

			if chance < rolled_chance then
				return
			end

			printf("Muting and suspending breathing, voiced actor sound playback '" ..
				file .. "' for total cooldown " .. cooldown + opt.speaking_cooldown .. "ms.")
			actor_speaking_cooldown_time = time_global() + cooldown + opt.speaking_cooldown

			if breath_snd then
				breath_snd.volume = 0
			end

			original_actor_speak(file, sound_volume, cooldown, 100, requires_squad, has_priority, ignore_conditionals,
				is_state)
		end
	end
end

function on_game_start()
	init_options()
	hook_functions()
end
