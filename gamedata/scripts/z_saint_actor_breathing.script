-- References

local is_respi_on = actor_effects.is_respi_on
local is_mask_on = actor_effects.is_mask_on

-- Types

local SOUND_KIND = {
	REGULAR = "breath",
	FEAR_SWEETENER = "shiver",
	HEALTH_RELATED = "health",
	STAMINA_RELATED = "run",
	STAMINA_RELATED_SWEETENER = "run_s",
	WEATHER_RAIN_SWEETENER = "weather_rain",
	HALLUCINATIONS = "hallucinations"
}

local SOUND_REGULAR_BREATH_MODE = {
	REGULAR = "1",
	MODERATE_DISTRESS = "2",
	EXTREME_DISTRESS = "3"
}

local SOUND_HEALTH_BREATH_MODE = {
	WOUNDED = "1"
}

local SOUND_RUN_BREATH_MODE = {
	LIGHTLY_EXHAUSTED = "1",
	MODERATELY_EXHAUSTED = "2"
}

local SOUND_PAUSE_FACTOR = {
	REGULAR = 1.4,
	MODERATE_DISTRESS = 1.3,
	EXTREME_DISTRESS = 1.3,
	STAMINA_RELATED = 1.3,
	HEALTH_RELATED = 1.3
}

local WEATHER_KIND = {
	CLEAR = "clear",
	PARTLY_CLOUDY = "partly",
	CLOUDY = "cloudy",
	FOGGY = "foggy",
	RAINING = "rain",
	STORM = "storm"
}

-- State

local opt = {}
local sound_cooldown_time = 0

local last_actor_speed = 0
local last_actor_position = { x = 0, y = 0, z = 0 }
local last_actor_speed_time = 0
local last_actor_hit_time = 0
local last_cam_dist = 0

local sound_action_cooldown_time = 0

local sound_object_ref = nil

local sound_index_by_kind = {}

local num_sounds_by_kind = {
	[SOUND_KIND.REGULAR] = 8,
	[SOUND_KIND.FEAR_SWEETENER] = 8,
	[SOUND_KIND.HEALTH_RELATED] = 8,
	[SOUND_KIND.STAMINA_RELATED] = 6,
	[SOUND_KIND.STAMINA_RELATED_SWEETENER] = 7,
	[SOUND_KIND.WEATHER_RAIN_SWEETENER] = 5,
	[SOUND_KIND.HALLUCINATIONS] = 5
}

-- Residuality means a mode is retained for some time after the condition is no longer met.
-- A given kind and mode are kept until the associated cooldown is hit.
-- Can add forced state transitions where a mode always has to be cycled back up.

-- Format for values: `{ mode = nil, pause_factor = 0, time = 0 }`
local sound_residual_cooldown_by_kind = {}

-- Configuration

local voiced_actor_blacklist = { "fear", "exhausted" }

-- Ticking

function tick_sound_index(kind)
	-- Tick all so breathing cycle is consistent between all kinds.

	for _, kind_identifier in pairs(SOUND_KIND) do
		local current_index = sound_index_by_kind[kind_identifier] or 0
		local num_sounds = num_sounds_by_kind[kind_identifier]

		sound_index_by_kind[kind_identifier] = current_index % num_sounds + 1
	end

	return sound_index_by_kind[kind]
end

function reset_breath_sound_index(kind)
	sound_index_by_kind[kind] = 0
end

function random_sound_index(kind)
	-- Allow random index picks for extra sounds (outside of breathing cycle).
	return math.random(1, num_sounds_by_kind[kind])
end

-- Init

function init_options()
	opt.speed = {}

	local ini_eff = ini_file("plugins\\actor_effects.ltx")
	local settings_speed = ini_eff:line_count("settings_speed")

	for i = 0, settings_speed - 1 do
		local _, id, value = ini_eff:r_line_ex("settings_speed", i, "", "")

		if id and value then
			opt.speed[id] = tonumber(value)
		end
	end

	opt.health = {
		injury_snd = nil,
		level1 = ini_eff:r_float_ex("settings_health", "level1"),
		level2 = ini_eff:r_float_ex("settings_health", "level2")
	}

	opt.cam_dist = ini_eff:r_float_ex("settings", "cam_dist") or 4

	opt.speaking_cooldown = 1000
	opt.item_use_cooldown = 6000
	opt.hit_distress_cooldown = 10000
	opt.residuality_time = 6000
	opt.fear_factor_npc_detection_radius = 50

	opt.breathing_sound_volume = 0.4
	opt.breathing_sound_volume_jitter = 0.1
	opt.breathing_sound_pitch_jitter = 0.1

	opt.enable_breathing_sound = ui_options.get("sound/environment/breathing_sound")
end

-- Actor Value Updates

function update_actor_cam_distance(actor)
	last_cam_dist = actor:bone_position("bip01_head"):distance_to_sqr(device().cam_pos)
end

function update_actor_speed(actor)
	local current_position = actor:position()
	local current_speed = (current_position.x - last_actor_position.x) ^ 2 +
		(current_position.y - last_actor_position.y) ^ 2 + (current_position.z - last_actor_position.z) ^ 2

	last_actor_position.x = current_position.x
	last_actor_position.y = current_position.y
	last_actor_position.z = current_position.z

	last_actor_speed = current_speed
end

function update_actor_speed_time()
	if (last_actor_speed > opt.speed.mini) then
		last_actor_speed_time = last_actor_speed_time + opt.speed.inc
	elseif last_actor_speed_time > opt.speed.dec then
		last_actor_speed_time = last_actor_speed_time - opt.speed.dec
	end
end

-- Actor Breathing Tick

function update_breathing(actor)
	if (not opt.enable_breathing_sound) then
		return
	end

	update_actor_cam_distance(actor)
	update_actor_speed(actor)
	update_actor_speed_time()

	handle_breathing_cycle(actor)
end

-- Actor Breathing

function handle_breathing_cycle(actor)
	local current_time = time_global()
	local actor_health = actor.health

	if (current_time < sound_cooldown_time) or (current_time < sound_action_cooldown_time) or (actor_health < 0) then
		return
	end

	-- Residual Sound

	for sound_kind, sound_record in pairs(sound_residual_cooldown_by_kind) do
		do
			if not sound_record or not sound_record.mode then
				goto continue
			end

			if current_time < sound_record.time then
				local sound_index = tick_sound_index(sound_kind)
				play_sound_with_parameters(actor, sound_kind, sound_record.mode, sound_index, sound_record.pause_factor)

				printf("Playing residual sound of kind '" ..
					sound_kind .. "' with mode " .. sound_record.mode .. " and index " ..
					sound_index .. " (expiration in " .. sound_record.time - current_time .. "ms).")
			else
				printf("Clearing residual sound of kind '" ..
					sound_kind ..
					"' with mode " ..
					sound_record.mode .. " (expired since " .. current_time - sound_record.time .. "ms).")

				-- Residual time window exceeded, clear record.
				sound_residual_cooldown_by_kind[sound_kind] = nil
			end

			return
		end

		::continue::
	end

	-- Health

	if actor_health <= opt.health.level2 then
		if actor_health <= opt.health.level1 and math.random() > 0.75 then
			-- Player is critically wounded, play sweetener.
			local sound_index = tick_sound_index(SOUND_KIND.FEAR_SWEETENER)
			play_sound_sweetener_with_parameters(actor, SOUND_KIND.FEAR_SWEETENER, sound_index,
				SOUND_PAUSE_FACTOR.HEALTH_RELATED)

			return
		end

		local sound_index = tick_sound_index(SOUND_KIND.HEALTH_RELATED)
		play_sound_with_parameters(actor, SOUND_KIND.HEALTH_RELATED, SOUND_HEALTH_BREATH_MODE.WOUNDED,
			sound_index, SOUND_PAUSE_FACTOR.HEALTH_RELATED, true)
		return
	end

	-- Stamina

	if actor.power < 0.8 or last_actor_speed_time > 0.5 then
		-- Player is running or low on stamina
		local sound_mode_power = round(3 / (3 * actor.power))
		local sound_mode_speed = round(3 * last_actor_speed_time / 44)
		local sound_mode_avg = round((sound_mode_power + sound_mode_speed) / 2)

		if sound_mode_avg > 2 and math.random() > 0.75 then
			-- Play sweetener sound
			local sound_index = tick_sound_index(SOUND_KIND.STAMINA_RELATED_SWEETENER)
			play_sound_sweetener_with_parameters(actor, SOUND_KIND.STAMINA_RELATED_SWEETENER, sound_index,
				SOUND_PAUSE_FACTOR.STAMINA_RELATED)

			printf("Playing stamina-related sweetener sound with mode average " .. sound_mode_avg .. " and index " ..
				sound_index .. ".")
			return
		end

		local sound_mode = clamp(sound_mode_avg, 1, 2)
		local sound_index = tick_sound_index(SOUND_KIND.STAMINA_RELATED)

		play_sound_with_parameters(actor, SOUND_KIND.STAMINA_RELATED, sound_mode, sound_index,
			SOUND_PAUSE_FACTOR.STAMINA_RELATED, true)
		printf("Playing stamina-related breathing sound with mode " ..
			tostring(sound_mode) ..
			" and index " ..
			tostring(sound_index) ..
			" (stamina " .. tostring(actor.power) .. ", last speed time " .. tostring(last_actor_speed_time) .. ").")
		return
	end

	-- Fear Factor

	local fear_factor = calculate_fear_factor()

	if fear_factor > 0.3 and get_psy_health() < 0.7 and math.random() > 0.9 then
		-- If fear is moderate and psy health is lowered, play hallucinations with a chance.
		local sound_index = random_sound_index(SOUND_KIND.HALLUCINATIONS)
		play_extra_sound_with_parameters(actor, SOUND_KIND.HALLUCINATIONS, sound_index)
		printf("Playing fear-related hallucinations extra sound with factor " ..
			fear_factor .. " and random index " .. tostring(sound_index) .. ".")
	end

	if fear_factor > 0.7 and math.random() > 0.75 then
		-- High distress, play fear sweetener.
		local sound_index = tick_sound_index(SOUND_KIND.FEAR_SWEETENER)
		play_sound_sweetener_with_parameters(actor, SOUND_KIND.FEAR_SWEETENER, sound_index, SOUND_PAUSE_FACTOR
			.EXTREME_DISTRESS)
		printf("Playing high fear factor sweetener sound with factor " ..
			fear_factor .. " and random index " .. tostring(sound_index) .. ".")
		return
	end

	if fear_factor > 0.7 or last_actor_hit_time + opt.hit_distress_cooldown > current_time then
		-- If fear is high or player was recently hit, switch to extreme distress for panicked breathing.
		local sound_index = tick_sound_index(SOUND_KIND.REGULAR)
		play_sound_with_parameters(actor, SOUND_KIND.REGULAR, SOUND_REGULAR_BREATH_MODE.EXTREME_DISTRESS, sound_index,
			SOUND_PAUSE_FACTOR.EXTREME_DISTRESS,
			true)
		printf("Playing high fear factor regular breathing sound with factor " ..
			fear_factor .. " and index " .. tostring(sound_index) .. ".")
		return
	end

	if fear_factor > 0.3 then
		-- If fear is moderate, switch to moderate distress for elevated breathing.
		local sound_index = tick_sound_index(SOUND_KIND.REGULAR)
		play_sound_with_parameters(actor, SOUND_KIND.REGULAR, SOUND_REGULAR_BREATH_MODE.MODERATE_DISTRESS, sound_index,
			SOUND_PAUSE_FACTOR.MODERATE_DISTRESS,
			true)
		printf("Playing low fear factor regular breathing sound with factor " ..
			fear_factor .. " and index " .. tostring(sound_index) .. ".")
		return
	end

	-- Weather

	local weather_kind = get_weather_kind()
	if (not get_is_masked(actor)) and (weather_kind == WEATHER_KIND.RAINING or weather_kind == WEATHER_KIND.STORM) and (math.random() > 0.9) then
		-- If it's raining or storming, play rain-related sweeteners.
		local sound_index = random_sound_index(SOUND_KIND.WEATHER_RAIN_SWEETENER)
		printf("Playing rain-related sweetener sound with weather " ..
			weather_kind .. " and index " .. tostring(sound_index) .. ".")
		play_sound_with_parameters(actor, SOUND_KIND.WEATHER_RAIN_SWEETENER, nil, sound_index, SOUND_PAUSE_FACTOR
			.REGULAR, true)
		return
	end

	-- Regular

	local sound_index = tick_sound_index(SOUND_KIND.REGULAR)
	play_sound_with_parameters(actor, SOUND_KIND.REGULAR, SOUND_REGULAR_BREATH_MODE.REGULAR, sound_index,
		SOUND_PAUSE_FACTOR.REGULAR, false)

	printf("Playing regular breathing sound with index " .. tostring(sound_index) .. ".")
end

-- Sound Playback

function play_sound_with_parameters(actor, kind, mode, index, pause_factor, should_reside)
	local sound_path = sound_path_from_parameters(actor, kind, mode, index)

	sound_object_ref = sound_object(sound_path)
	sound_object_ref:play(actor, 0, sound_object.s2d)
	sound_object_ref.volume = actor_sound_volume()

	local current_time = time_global()
	local sound_duration = sound_object_ref:length() or 800

	sound_cooldown_time = current_time + sound_duration * pause_factor

	if should_reside then
		register_residual_sound(kind, mode, pause_factor)
	end
end

function play_sound_sweetener_with_parameters(actor, kind, index, pause_factor)
	local sound_path = sound_path_from_parameters(actor, kind, nil, index)

	sound_object_ref = sound_object(sound_path)
	sound_object_ref:play(actor, 0, sound_object.s2d)
	sound_object_ref.volume = actor_sound_volume()
	sound_object_ref.frequency = actor_sound_frequency()

	local current_time = time_global()
	sound_cooldown_time = current_time + sound_object_ref:length() or 1000 * pause_factor
end

function play_extra_sound_with_parameters(actor, kind, index)
	local sound_path = "actor\\" .. kind .. "_" .. index

	local extra_sound_object_ref = sound_object(sound_path)
	extra_sound_object_ref:play(actor, 0, sound_object.s2d)
	extra_sound_object_ref.volume = 0.5
end

function sound_path_from_parameters(actor, kind, mode, index)
	local sound_name

	if mode ~= nil then
		sound_name = kind .. "_" .. mode .. "_" .. index
	else
		sound_name = kind .. "_" .. index
	end

	if get_is_masked() then
		sound_name = "m_" .. sound_name
	end

	return "actor\\" .. sound_name
end

-- Residual Sound Registration

function register_residual_sound(kind, mode, pause_factor)
	sound_residual_cooldown_by_kind[kind] = {
		mode = mode,
		pause_factor = pause_factor,
		time = time_global() + opt.residuality_time
	}
end

-- Sound Metadata

function actor_sound_volume(is_masked)
	if last_cam_dist > opt.cam_dist then
		return 0
	end

	-- local amplifier = (is_masked or false) and 0.5 or 1 -- Remove this?
	local amplifier = 1
	local jitter = random_float(-opt.breathing_sound_volume_jitter, opt.breathing_sound_volume_jitter)

	return (1 - last_cam_dist / opt.cam_dist) * amplifier * opt.breathing_sound_volume + jitter
end

function actor_sound_frequency()
	return random_float(-opt.breathing_sound_pitch_jitter, opt.breathing_sound_pitch_jitter)
end

-- Fear Factor

function calculate_fear_factor()
	local is_night = get_is_night()
	local is_underground = get_is_underground()
	local is_in_combat = get_is_in_combat()
	local is_surge = get_is_surge()
	local is_in_safe_space = get_is_in_safe_space()
	local psy_health = get_psy_health()
	local nearby_threats = get_number_of_nearby_threats()
	local number_of_hostile_npcs = nearby_threats.npcs
	local number_of_monsters = nearby_threats.monsters

	local fear_value = 0

	fear_value = fear_value + clamp((1 / psy_health - 1), 0, 5)

	if is_in_combat then
		fear_value = fear_value + 1
		fear_value = fear_value + clamp(number_of_hostile_npcs, 0, 4) / 4
		fear_value = fear_value + clamp(number_of_monsters, 0, 4)
	end

	if is_night then
		fear_value = fear_value + 1
	end

	if is_underground then
		fear_value = fear_value + 2
	end

	if is_surge and not is_underground then
		fear_value = fear_value + 2
	end

	if is_in_safe_space and not is_underground then
		fear_value = fear_value / 2
	end

	local fear_factor = clamp(fear_value / 10, 0, 1)

	printf("Calculated aggregate player fear factor: " ..
		tostring(fear_factor) ..
		" (from value " ..
		fear_value ..
		") with factors (in combat: " ..
		tostring(is_in_combat) .. ", night: " .. tostring(is_night) .. ", underground: " ..
		tostring(is_underground) ..
		", surge: " .. tostring(is_surge) .. ", safe space: " .. tostring(is_in_safe_space) ..
		", psy health: " ..
		tostring(psy_health) ..
		", nearby hostiles: " ..
		tostring(number_of_hostile_npcs) .. ", nearby monsters: " .. tostring(number_of_monsters) .. ").")

	return fear_factor
end

-- Conditions

function get_is_surge()
	return xr_conditions.surge_started()
end

function get_is_night()
	return level.get_time_hours() < 3 or level.get_time_hours() > 22
end

function get_is_underground()
	return GetEvent("underground")
end

function get_is_in_safe_space()
	return GetEvent("current_safe_cover")
end

function get_is_in_combat()
	if not AGDD_voiced_actor then
		return false
	end

	return AGDD_voiced_actor.is_actor_in_combat() or false
end

function get_psy_health()
	if arszi_psy then
		return arszi_psy.get_psy_health()
	end

	return db.actor:psy_health()
end

function get_weather_kind()
	local weather_manager = level_weathers.get_weather_manager()
	local weather_kind = weather_manager:get_curr_weather()

	return weather_kind
end

function get_is_masked()
	local actor = db.actor
	return is_mask_on(actor) or is_respi_on(actor)
end

function get_number_of_nearby_threats()
	local max_radius = opt.fear_factor_npc_detection_radius
	local number_of_hostile_npcs = 0
	local number_of_monsters = 0

	level.iterate_nearest(db.actor:position(), max_radius, function(obj)
		if IsMonster(obj) and obj:alive() then
			number_of_monsters = number_of_monsters + 1
		end

		if IsStalker(obj) and obj:alive() and obj:relation(db.actor) == game_object.enemy then
			number_of_hostile_npcs = number_of_hostile_npcs + 1
		end
	end)

	return { npcs = number_of_hostile_npcs, monsters = number_of_monsters }
end

-- Utility

function table.has_value(tab, val)
	for _, value in ipairs(tab) do
		if value == val then
			return true
		end
	end

	return false
end

-- Hook

function hook_functions()
	actor_effects.Update_Breathing = update_breathing
	actor_effects.play_sound_breath_mask = play_sound_breath_mask
	actor_effects.play_sound_breath = play_sound_breath

	if AGDD_voiced_actor then
		local original_actor_speak = AGDD_voiced_actor.actor_speak

		AGDD_voiced_actor.actor_speak = function(file, sound_volume, cooldown, chance, requires_squad, has_priority,
												 ignore_conditionals, is_state)
			-- Check blacklist, skip playback for sounds already handled in breathing script.
			for _, blacklisted_word in ipairs(voiced_actor_blacklist) do
				if string.find(file, blacklisted_word) then
					return
				end
			end

			-- Alter regular hurt sounds, block above higher health threshold.
			if string.find(file, "hurt_bad") or string.find(file, "hunger") or string.find(file, "thirst") or string.find(file, "tired") then
				chance = chance / 4
			elseif string.find(file, "hurt") then
				if db.actor:health() > 0.5 then
					return
				end

				chance = chance / 4
			end

			-- Fix playback volume for player hurt sounds, remove dependency on player health.
			if string.find(file, "hurt") or string.find(file, "sanity") then
				sound_volume = 1.0
			end

			-- Detect player hit via pain sound call, increase fear factor to max to simulate adrenaline rush.
			if string.find(file, "pain") then
				last_actor_hit_time = time_global()
			end

			-- Augment random chance for playback, replace voiced actor script logic.
			local rolled_chance = math.random(1, 100)

			if chance < rolled_chance then
				return
			end

			printf("Muting and suspending breathing, voiced actor sound playback '" ..
				file .. "' for total cooldown " .. cooldown + opt.speaking_cooldown .. "ms.")
			sound_action_cooldown_time = time_global() + cooldown + opt.speaking_cooldown

			if sound_object_ref then
				sound_object_ref.volume = 0
			end

			original_actor_speak(file, sound_volume, cooldown, 100, requires_squad, has_priority, ignore_conditionals,
				is_state)
		end
	end

	if actor_effects then
		local original_play_item_fx = actor_effects.play_item_fx
		actor_effects.play_item_fx = function(item)
			printf("Player used item (via play item fx), setting action cooldown time to " ..
				opt.item_use_cooldown .. "ms.")
			sound_action_cooldown_time = time_global() + opt.item_use_cooldown
			original_play_item_fx(item)
		end
	end

	if enhanced_animations then
		local original_start_anim = enhanced_animations.start_anim
		enhanced_animations.start_anim = function(anim_section_hud)
			printf("Player used item (via enhanced animations start anim), setting action cooldown time to " ..
				opt.item_use_cooldown .. "ms.")
			sound_action_cooldown_time = time_global() + opt.item_use_cooldown
			original_start_anim(anim_section_hud)
		end
	end
end

function on_game_start()
	init_options()
	hook_functions()
end
